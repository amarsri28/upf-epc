From dcae77e6670bd4cc5b0f318075c1acc2578af9e5 Mon Sep 17 00:00:00 2001
From: Amar Srivastava <amarsri28@gmail.com>
Date: Thu, 26 Nov 2020 22:23:42 -0800
Subject: [PATCH] Dpdk hash support in Bess

---
 core/modules/wildcard_match.cc | 103 +++++++++++++++++------
 core/modules/wildcard_match.h  |  27 +++++-
 core/utils/cuckoo_map.h        | 145 ++++++++++++++++++++++++++++++++-
 core/utils/exact_match_table.h |  97 ++++++++++++++++++----
 4 files changed, 326 insertions(+), 46 deletions(-)

diff --git a/core/modules/wildcard_match.cc b/core/modules/wildcard_match.cc
index ec639a7b..db501f12 100644
--- a/core/modules/wildcard_match.cc
+++ b/core/modules/wildcard_match.cc
@@ -56,6 +56,22 @@ static inline int is_valid_gate(gate_idx_t gate) {
   return (gate < MAX_GATES || gate == DROP_GATE);
 }
 
+
+void WildcardMatch::Initkeys(wm_hkey_t *keys)//,size_t key_size)
+  {
+    int i = sizeof(wm_hkey_t) - WildcardMatch::total_key_size_;
+    if(i)
+    {
+      int j = i/sizeof(keys->u64_arr[0]);
+      int total_size =  sizeof(wm_hkey_t)/sizeof(keys->u64_arr[0]);
+      for(int i= total_size -j; i<total_size;i++)
+      {
+        keys->u64_arr[i] = 0;
+      }
+    }
+  }
+
+
 const Commands WildcardMatch::cmds = {
     {"get_initial_arg", "EmptyArg",
      MODULE_CMD_FUNC(&WildcardMatch::GetInitialArg), Command::THREAD_SAFE},
@@ -156,7 +172,7 @@ CommandResponse WildcardMatch::Init(const bess::pb::WildcardMatchArg &arg) {
 
   return CommandSuccess();
 }
-
+//func work is to mask with incoming key and check in table if exist, mask is obj specific..
 inline gate_idx_t WildcardMatch::LookupEntry(const wm_hkey_t &key,
                                              gate_idx_t def_gate,
                                              bess::Packet *pkt) {
@@ -164,21 +180,33 @@ inline gate_idx_t WildcardMatch::LookupEntry(const wm_hkey_t &key,
       .priority = INT_MIN, .ogate = def_gate, .keyv = {{0}}};
 
   for (auto &tuple : tuples_) {
-    const auto &ht = tuple.ht;
+    const auto &ht = tuple.ht; //take one class obj... and search masked-key in this...
     wm_hkey_t key_masked;
 
+//add existing mask in new incoming key and search if its available in curent table
     mask(&key_masked, key, tuple.mask, total_key_size_);
 
-    const auto *entry =
-        ht.Find(key_masked, wm_hash(total_key_size_), wm_eq(total_key_size_));
-
-    if (entry && entry->second.priority >= result.priority) {
-      result = entry->second;
+      WmData* entry =nullptr;
+      Initkeys(&key_masked); //u64_arr
+//      std::cout << "Wildcard:Find"<< "key="<<key_masked.u64_arr[0] << ","<< key_masked.u64_arr[1]<< ","<<key_masked.u64_arr[2] << ","<<key_masked.u64_arr[3] << ","<< key_masked.u64_arr[4] << ","<< key_masked.u64_arr[5] << ","<<key_masked.u64_arr[6] << ","<<key_masked.u64_arr[7] << std::endl;
+    
+     //int ret =  
+     ht->Find_dpdk(&key_masked,((void**)&entry) );  
+ /* debug prints
+    if(ret <0) {
+        std::cout <<"Wildcard:Find dpdk failed" <<std::endl;
+   
+      }
+      else std::cout <<"Find_dpdk pass" <<std::endl;
+*/
+    if (entry && entry->priority >= result.priority) {
+      result = *entry;
     }
   }
 
   /* if lookup was successful, then set values (if possible) */
   if (result.ogate != default_gate_) {
+  //  std::cout << "Wildcard:lookup sucess"<<std::endl;
     size_t num_values_ = values_.size();
     for (size_t i = 0; i < num_values_; i++) {
       int value_size = values_[i].size;
@@ -229,6 +257,8 @@ inline gate_idx_t WildcardMatch::LookupEntry(const wm_hkey_t &key,
       }
     }
   }
+
+ //  std::cout << "Wildcard:lookup NOT sucess"<<std::endl;
   return result.ogate;
 }
 
@@ -282,7 +312,7 @@ std::string WildcardMatch::GetDesc() const {
   int num_rules = 0;
 
   for (const auto &tuple : tuples_) {
-    num_rules += tuple.ht.Count();
+    num_rules += tuple.ht->Count();
   }
 
   return bess::utils::Format("%zu fields, %d rules", fields_.size(), num_rules);
@@ -412,17 +442,21 @@ int WildcardMatch::AddTuple(wm_hkey_t *mask) {
 
 bool WildcardMatch::DelEntry(int idx, wm_hkey_t *key) {
   struct WmTuple &tuple = tuples_[idx];
-  bool ret =
-      tuple.ht.Remove(*key, wm_hash(total_key_size_), wm_eq(total_key_size_));
-  if (!ret) {
-    return ret;
+  Initkeys(key);
+ // std::cout << "Wildcard:Delete"<< "key="<<key->u64_arr[0] << ","<< key->u64_arr[1]<< ","<<key->u64_arr[2] << ","<<key->u64_arr[3] << ","<< key->u64_arr[4] << ","<< key->u64_arr[5] << ","<<key->u64_arr[6] << ","<<key->u64_arr[7] << std::endl;
+ 
+    int ret =
+      tuple.ht->Remove(*key, wm_hash(total_key_size_), wm_eq(total_key_size_));
+  if (ret>=0){
+  //  std::cout <<"wildcard remove pass" <<std::endl;
+    return true;
   }
 
-  if (tuple.ht.Count() == 0) {
+  if (tuple.ht->Count() == 0) {
     tuples_.erase(tuples_.begin() + idx);
   }
 
-  return true;
+  return false;
 }
 
 CommandResponse WildcardMatch::CommandAdd(
@@ -430,11 +464,11 @@ CommandResponse WildcardMatch::CommandAdd(
   gate_idx_t gate = arg.gate();
   int priority = arg.priority();
 
-  wm_hkey_t key = {{0}};
+  wm_hkey_t key =  {{0}};
   wm_hkey_t mask = {{0}};
 
   struct WmData data;
-
+ 
   CommandResponse err = ExtractKeyMask(arg, &key, &mask);
   if (err.error().code() != 0) {
     return err;
@@ -444,27 +478,35 @@ CommandResponse WildcardMatch::CommandAdd(
     return CommandFailure(EINVAL, "Invalid gate: %hu", gate);
   }
 
-  err = ExtractValue(arg, &data.keyv);
+  err = ExtractValue(arg, &(data.keyv));
   if (err.error().code() != 0) {
     return err;
   }
 
   data.priority = priority;
   data.ogate = gate;
-
-  int idx = FindTuple(&mask);
+ 
+   int idx = FindTuple(&mask);
   if (idx < 0) {
     idx = AddTuple(&mask);
     if (idx < 0) {
       return CommandFailure(-idx, "failed to add a new wildcard pattern");
     }
   }
-
-  auto *ret = tuples_[idx].ht.Insert(key, data, wm_hash(total_key_size_),
-                                     wm_eq(total_key_size_));
-  if (ret == nullptr) {
+  Initkeys(&key);
+ //  std::cout << "Wildcard:Insert"<< "key="<<key.u64_arr[0] << ","<< key.u64_arr[1]<< ","<<key.u64_arr[2] << ","<<key.u64_arr[3] << ","<< key.u64_arr[4] << ","<< key.u64_arr[5] << ","<<key.u64_arr[6] << ","<<key.u64_arr[7] << std::endl;
+ 
+     struct WmData* data_t = new WmData(data);
+  //   std::cout <<"ogate:" << data_t->ogate  << "priority:" << data_t->priority <<"keyv:" <<data_t->keyv.u64_arr[0] <<std::endl;
+     
+    int ret = tuples_[idx].ht->Insert_dpdk(&key, data_t);//, wm_hash(total_key_size_),
+
+    if (ret <0) 
+    {
+  //   std::cout <<"wildcard: Insert failed" <<std::endl;
     return CommandFailure(EINVAL, "failed to add a rule");
   }
+ // else std::cout <<"wildcard::dpdk insert passed"<<std::endl;
 
   return CommandSuccess();
 }
@@ -485,7 +527,7 @@ CommandResponse WildcardMatch::CommandDelete(
   }
 
   int ret = DelEntry(idx, &key);
-  if (!ret) {
+  if (ret < 0) {
     return CommandFailure(-ret, "failed to delete a rule");
   }
 
@@ -499,7 +541,7 @@ CommandResponse WildcardMatch::CommandClear(const bess::pb::EmptyArg &) {
 
 void WildcardMatch::Clear() {
   for (auto &tuple : tuples_) {
-    tuple.ht.Clear();
+    tuple.ht->Clear();
   }
 }
 
@@ -521,9 +563,14 @@ CommandResponse WildcardMatch::GetInitialArg(const bess::pb::EmptyArg &) {
 // Retrieves a WildcardMatchConfig that would restore this module's
 // runtime configuration.
 CommandResponse WildcardMatch::GetRuntimeConfig(const bess::pb::EmptyArg &) {
+std::pair<wm_hkey_t, WmData> entry;
   bess::pb::WildcardMatchConfig resp;
   using rule_t = bess::pb::WildcardMatchCommandAddArg;
+const wm_hkey_t *key = 0;
+
+  WmData *data;  
 
+  uint32_t *next =0;
   resp.set_default_gate(default_gate_);
 
   // Each tuple provides a single mask, which may have many data-matches.
@@ -531,7 +578,11 @@ CommandResponse WildcardMatch::GetRuntimeConfig(const bess::pb::EmptyArg &) {
     wm_hkey_t mask = tuple.mask;
     // Each entry in the hash table has priority, ogate, and the data
     // (one datum per field, under the mask for this field).
-    for (auto &entry : tuple.ht) {
+   //  for (auto &entry : tuple.ht) 
+    while( (tuple.ht->Iterate((const void**)&key, (void**)&data, next)) >= (int)0)
+    {
+       entry.first = *key;
+       entry.second =  *data;
       // Create the rule instance
       rule_t *rule = resp.add_rules();
       rule->set_priority(entry.second.priority);
diff --git a/core/modules/wildcard_match.h b/core/modules/wildcard_match.h
index 85deeafc..4d775f35 100644
--- a/core/modules/wildcard_match.h
+++ b/core/modules/wildcard_match.h
@@ -128,9 +128,19 @@ class wm_hash {
  private:
   size_t len_;
 };
-
+struct rte_hash_parameters dpdk_params1{
+      .name= "test2",
+      .entries = 1<<20,
+      .reserved = 0,
+      .key_len = sizeof(wm_hkey_t),
+      .hash_func = rte_hash_crc,
+      .hash_func_init_val = 0,
+      .socket_id = (int)rte_socket_id(),
+      .extra_flag = RTE_HASH_EXTRA_FLAGS_RW_CONCURRENCY};
 class WildcardMatch final : public Module {
  public:
+ 
+
   static const gate_idx_t kNumOGates = MAX_GATES;
 
   static const Commands cmds;
@@ -143,7 +153,7 @@ class WildcardMatch final : public Module {
         fields_(),
         values_(),
         tuples_() {
-    max_allowed_workers_ = Worker::kMaxWorkers;
+        max_allowed_workers_ = Worker::kMaxWorkers;
   }
 
   CommandResponse Init(const bess::pb::WildcardMatchArg &arg);
@@ -161,10 +171,20 @@ class WildcardMatch final : public Module {
   CommandResponse CommandClear(const bess::pb::EmptyArg &arg);
   CommandResponse CommandSetDefaultGate(
       const bess::pb::WildcardMatchCommandSetDefaultGateArg &arg);
+   void Initkeys(wm_hkey_t *keys);
 
  private:
   struct WmTuple {
-    CuckooMap<wm_hkey_t, struct WmData, wm_hash, wm_eq> ht;
+    WmTuple()
+     {
+      
+       std::ostringstream address;
+      address << (void const *)this;
+      std::string name = "wildcard" + address.str();
+      dpdk_params1.name= name.c_str();
+       ht = new CuckooMap<wm_hkey_t, struct WmData, wm_hash, wm_eq>(0,0,&dpdk_params1);
+     }
+    CuckooMap<wm_hkey_t, struct WmData, wm_hash, wm_eq> *ht;
     wm_hkey_t mask;
   };
 
@@ -194,6 +214,7 @@ class WildcardMatch final : public Module {
   std::vector<struct WmField> fields_;
   std::vector<struct WmField> values_;
   std::vector<struct WmTuple> tuples_;
+  std::vector<struct WmData> data_;
 };
 
 #endif  // BESS_MODULES_WILDCARDMATCH_H_
diff --git a/core/utils/cuckoo_map.h b/core/utils/cuckoo_map.h
index c855b93d..2c83d44b 100644
--- a/core/utils/cuckoo_map.h
+++ b/core/utils/cuckoo_map.h
@@ -50,6 +50,8 @@
 
 #include "../debug.h"
 #include "common.h"
+#include <rte_hash.h>
+#include <iostream>
 
 namespace bess {
 namespace utils {
@@ -74,6 +76,11 @@ typedef uint32_t EntryIndex;
 template <typename K, typename V, typename H = std::hash<K>,
           typename E = std::equal_to<K>>
 class CuckooMap {
+ private:
+ struct rte_hash *hash = nullptr;
+ bool IsDpdk =false;
+ uint32_t key_len =0;
+ rte_hash_parameters rt;
  public:
   typedef std::pair<K, V> Entry;
 
@@ -149,20 +156,38 @@ class CuckooMap {
   };
 
   CuckooMap(size_t reserve_buckets = kInitNumBucket,
-            size_t reserve_entries = kInitNumEntries)
+            size_t reserve_entries = kInitNumEntries,void* dpdk_params=0)
       : bucket_mask_(reserve_buckets - 1),
         num_entries_(0),
         buckets_(reserve_buckets),
         entries_(reserve_entries),
         free_entry_indices_() {
+ 
+        if(dpdk_params)
+         {
+          if( hash == NULL)
+          {
+         	rt = *((rte_hash_parameters *) dpdk_params);
+          key_len = rt.key_len;
+          hash = rte_hash_create(&rt);
+ 
+          if(hash==NULL)
+          throw std::runtime_error("DPDK rte_hash_create() returned null , cant proceed further");
+          }
+          IsDpdk =  true;
+         }
+         else
+         {
     // the number of buckets must be a power of 2
     CHECK_EQ(align_ceil_pow2(reserve_buckets), reserve_buckets);
 
     for (int i = reserve_entries - 1; i >= 0; --i) {
       free_entry_indices_.push(i);
     }
+         }
   }
 
+ 
   // Not allowing copying for now
   CuckooMap(CuckooMap&) = delete;
   CuckooMap& operator=(CuckooMap&) = delete;
@@ -176,6 +201,17 @@ class CuckooMap {
 
   template <typename... Args>
   Entry* DoEmplace(const K& key, const H& hasher, const E& eq, Args&&... args) {
+       
+     if(IsDpdk)
+     {       
+      Entry *entry1 = new Entry;
+      new (&entry1->second) V(std::forward<Args>(args)...);
+      int ret1 = rte_hash_add_key_data(hash, &key,(void*)(&entry1->second));
+      if(ret1<0)return nullptr;
+      entry1->first=key;
+      return entry1;
+    }
+
     Entry* entry;
     HashResult primary = Hash(key, hasher);
 
@@ -220,6 +256,59 @@ class CuckooMap {
     return DoEmplace(key, hasher, eq, std::move(value));
   }
 
+int Insert_dpdk(const void *key, void *data=0, hash_sig_t sig=0)
+ {
+     if(IsDpdk)
+     {       
+        if(data && !sig)
+        {
+         return rte_hash_add_key_data(hash, key, data);
+        }
+        if(data &&sig)
+        {
+          return rte_hash_add_key_with_hash_data(hash,key, sig, data);
+        }
+        if (!data && !sig)
+        {
+        return rte_hash_add_key(hash, key);
+        }
+     }
+    return -1; 
+}
+
+int Find_dpdk(const void *key, void **data=0, hash_sig_t sig=0)
+{
+if(IsDpdk )
+  {
+  if(data && !sig)
+     return rte_hash_lookup_data(hash, key, data);
+  if(data && sig)
+     return rte_hash_lookup_with_hash_data(hash,key, sig, data);
+  if(!data && !sig)
+      return rte_hash_lookup(hash, key);
+  if(!data && sig)
+      return rte_hash_lookup_with_hash(hash,key,sig);
+ }
+      return -1;
+}
+
+ int Find_dpdk(const void *key, void **data=0, hash_sig_t sig=0) const
+{
+ 
+ if(IsDpdk )
+  {
+  if(data && !sig)
+     return rte_hash_lookup_data(hash, key, data);
+  if(data && sig)
+     return rte_hash_lookup_with_hash_data(hash,key, sig, data);
+  if(!data && !sig)
+      return rte_hash_lookup(hash, key);
+  if(!data && sig)
+      return rte_hash_lookup_with_hash(hash,key,sig);
+ }
+      return -1;
+}
+
   // Emplace/update-in-place a key value pair
   // On success returns a pointer to the inserted entry, nullptr otherwise.
   // NOTE: when Emplace() returns nullptr, the constructor of `V` may not be
@@ -242,6 +331,17 @@ class CuckooMap {
   // const version of Find()
   const Entry* Find(const K& key, const H& hasher = H(),
                     const E& eq = E()) const {
+
+    if(IsDpdk)
+     {
+       Entry* ans = new Entry;
+       V* data;
+       int ret = rte_hash_lookup_data(hash, &key,(void**)&data);
+       if(ret<0) return NULL;
+       ans->first =key;
+       ans->second =*data;
+       return ans;
+      }
     EntryIndex idx = FindWithHash(Hash(key, hasher), key, eq);
     if (idx == kInvalidEntryIdx) {
       return nullptr;
@@ -255,6 +355,13 @@ class CuckooMap {
   // Remove the stored entry by the key
   // Return false if not exist.
   bool Remove(const K& key, const H& hasher = H(), const E& eq = E()) {
+
+    if(IsDpdk)
+    { 
+    int ret = rte_hash_del_key(hash, &key);
+     if(ret < 0)return false;
+     else return true;
+    }
     HashResult pri = Hash(key, hasher);
     if (RemoveFromBucket(pri, pri & bucket_mask_, key, eq)) {
       return true;
@@ -267,6 +374,19 @@ class CuckooMap {
   }
 
   void Clear() {
+
+    if(IsDpdk) 
+    {
+     if(hash)
+      {
+         rte_hash_free(hash);
+         hash=nullptr;
+         hash = rte_hash_create(&rt);
+         if(hash == NULL)
+           throw std::runtime_error("DPDK rte_hash_create() returned null , cant proceed further");
+      }
+    return;
+    }
     buckets_.clear();
     entries_.clear();
 
@@ -286,8 +406,29 @@ class CuckooMap {
   }
 
   // Return the number of stored entries
-  size_t Count() const { return num_entries_; }
+  size_t Count() const 
+  {
+    if(IsDpdk)
+         return rte_hash_count(hash);
+    else 
+     return num_entries_; 
+  }
 
+  //bulk data look up bess func
+ int32_t Lookup_Bulk_data(const void **keys,
+		      uint32_t num_keys, uint64_t *hit_mask, void *data[])
+ {
+   if(IsDpdk)
+   return rte_hash_lookup_bulk_data(hash, keys,num_keys, hit_mask, data);
+   return -1;
+ }
+//iterate for dpdk hash
+int32_t Iterate(const void **key, void **data, uint32_t *next)
+{
+ if(IsDpdk)
+ return rte_hash_iterate(hash, key, data, next);
+ return -1;
+}
  protected:
   // Tunable macros
   static const int kInitNumBucket = 4;
diff --git a/core/utils/exact_match_table.h b/core/utils/exact_match_table.h
index 7c0cfda4..c60007d9 100644
--- a/core/utils/exact_match_table.h
+++ b/core/utils/exact_match_table.h
@@ -155,7 +155,18 @@ typedef std::vector<std::vector<uint8_t>> ExactMatchRuleFields;
 template <typename T>
 class ExactMatchTable {
  public:
-  using EmTable =
+ struct rte_hash_parameters dpdk_params1 
+ {
+      .name= "test1",
+      .entries = 1<<20,
+      .reserved = 0,
+      .key_len = sizeof(ExactMatchKey),
+      .hash_func = rte_hash_crc,
+      .hash_func_init_val = 0,
+      .socket_id = (int)rte_socket_id(),
+      .extra_flag = RTE_HASH_EXTRA_FLAGS_RW_CONCURRENCY};
+
+   using EmTable =
       CuckooMap<ExactMatchKey, T, ExactMatchKeyHash, ExactMatchKeyEq>;
 
   ExactMatchTable()
@@ -163,8 +174,25 @@ class ExactMatchTable {
         total_key_size_(),
         num_fields_(),
         fields_(),
-        table_() {}
+        table_(0,0,&dpdk_params1) {  }
+
+ void Initkeys(ExactMatchKey *keys)
+  {
+    int i = sizeof(ExactMatchKey) - total_key_size_;
+    if(i)
+    {
+      int j = i/sizeof(keys->u64_arr[0]);
+      int total_size =  sizeof(ExactMatchKey)/sizeof(keys->u64_arr[0]);
+      for(int i= total_size -j; i<total_size;i++)
+      {
+         keys->u64_arr[i] = 0;
+      }
+    }
+  }
+
 
+  
+ 
   // Add a new rule.
   //
   // @param fields
@@ -183,10 +211,18 @@ class ExactMatchTable {
     if ((err = gather_key(fields, &key)).first != 0) {
       return err;
     }
-
-    table_.Insert(key, val, ExactMatchKeyHash(total_key_size_),
-                  ExactMatchKeyEq(total_key_size_));
-
+     Initkeys(&key);
+     const void* Key_t = (const void*)&key;
+
+     //val_.emplace_back();  
+     //T &v = val_.back(); // */ 
+     T* val_t = new T(val);
+       
+   
+    int ret = table_.Insert_dpdk(Key_t, val_t);
+    if(ret<0)
+             return MakeError(EINVAL, "Exactmatch insert failed");
+          
     return MakeError(0);
   }
 
@@ -206,6 +242,7 @@ class ExactMatchTable {
     if ((err = gather_key(fields, &key)).first != 0) {
       return err;
     }
+    Initkeys(&key);
 
     bool ret = table_.Remove(key, ExactMatchKeyHash(total_key_size_),
                              ExactMatchKeyEq(total_key_size_));
@@ -271,10 +308,21 @@ class ExactMatchTable {
   // Find an entry in the table.
   // Returns the value if `key` matches a rule, otherwise `default_value`.
   T Find(const ExactMatchKey &key, const T &default_value) const {
-    const auto &table = table_;
-    const auto *entry = table.Find(key, ExactMatchKeyHash(total_key_size_),
-                                   ExactMatchKeyEq(total_key_size_));
-    return entry ? entry->second : default_value;
+    //const auto &table = table_;
+
+    ExactMatchKey &t1 = const_cast<ExactMatchKey&>(key) ;
+
+    const_cast<ExactMatchTable *>(this)->Initkeys(&t1); 
+    void *data = nullptr;
+    
+    table_.Find_dpdk( &key,&data); 
+
+    if(data)
+    {
+    T data_t = *((T*)data) ;
+    return data_t;
+    }
+    else return default_value;
   }
 
   // Find entries for `n` `keys` in the table and store their values in in
@@ -283,11 +331,29 @@ class ExactMatchTable {
   void Find(const ExactMatchKey *keys, T *vals, size_t n,
             T default_value) const {
     const auto &table = table_;
-    for (size_t i = 0; i < n; i++) {
-      const auto *entry =
-          table.Find(keys[i], ExactMatchKeyHash(total_key_size_),
-                     ExactMatchKeyEq(total_key_size_));
-      vals[i] = entry ? entry->second : default_value;
+    uint64_t *hit_mask;
+    int num =0;
+  
+    for (size_t i = 0; i < n; i=i+32) {
+    num= (n-i >= 32) ?32:n-i;
+    
+    for(int h=0;h<num;h++)
+    {
+    Initkeys(&keys[h]);
+    }
+    void* k = &keys[i];
+    int ans = table_.Lookup_Bulk_data(&k,num, hit_mask, &vals[i]);
+     if(ans != num)
+     {
+       for (int k = 0; k < num; k++) {
+					if ((*hit_mask & (1ULL << k))  == 0) 
+           {
+					vals[k]= default_value;
+					}
+          }
+      
+     }
+     
     }
   }
 
@@ -452,6 +518,7 @@ class ExactMatchTable {
   ExactMatchField fields_[MAX_FIELDS];
 
   EmTable table_;
+  std::vector<T> val_;
 };
 
 }  // namespace bess
-- 
2.25.1

